/*
 * This code was auto generated by AfterShip SDK Generator.
 * Do not edit the class manually.
 */
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Web;

namespace AfterShipTracking
{
    /// <summary>
    /// Authenticator
    /// </summary>
    public class Authenticator
    {
        public static readonly string API_KEY = "API_KEY";
        public static readonly string AUTH_TYPE_AES = "AES";
        public static readonly string AUTH_TYPE_RSA = "RSA";

        /// <summary>
        /// API key
        /// </summary>
        public string ApiKey { get; set; }

        /// <summary>
        /// API secret
        /// </summary>
        public string ApiSecret { get; set; }

        /// <summary>
        /// Authentication type
        /// </summary>
        public string AuthenticationType { get; set; }

        /// <summary>
        /// Create a new Authenticator
        /// </summary>
        /// <param name="apiKey"></param>
        /// <param name="apiSecret"></param>
        /// <param name="authenticationType"></param>
        public Authenticator(string apiKey, string apiSecret, string authenticationType)
        {
            this.ApiKey = apiKey;
            this.ApiSecret = apiSecret;
            this.AuthenticationType = authenticationType;
        }

        public void Sign(HttpRequestMessage request)
        {
            if (this.AuthenticationType != API_KEY)
            {
                HttpHeaders tmpHeaders = request.Headers;
                string h = CanonicalHeader(tmpHeaders);
                string rs;
                try
                {
                    rs = CanonicalResource(request);
                }
                catch (Exception e)
                {
                    throw ErrorCode.GenSDKError(ErrorCode.INVALID_REQUEST, e.Message);
                }

                byte[] bodyBytes;
                using (MemoryStream ms = new MemoryStream())
                {
                    if (request.Content != null)
                    {
                        request.Content.CopyToAsync(ms).Wait();
                    }
                    bodyBytes = ms.ToArray();
                }
                string bodyString = Encoding.UTF8.GetString(bodyBytes);
                string s = SignString(
                    request.Method.ToString(),
                    bodyString,
                    request.Headers.GetValues("date").First(),
                    h,
                    rs
                );
                if (this.AuthenticationType == AUTH_TYPE_AES)
                {
                    string aesSign = Encryption.HmacSha256Encrypt(s, this.ApiSecret);
                    tmpHeaders.TryAddWithoutValidation("as-signature-hmac-sha256", aesSign);
                }
                else if (this.AuthenticationType == AUTH_TYPE_RSA)
                {
                    string rsaSign;
                    try
                    {
                        rsaSign = Encryption.RsaPssSha256Encrypt(s, this.ApiSecret);
                    }
                    catch (Exception e)
                    {
                        throw ErrorCode.GenSDKError(ErrorCode.INVALID_API_KEY, e.Message);
                    }

                    tmpHeaders.TryAddWithoutValidation("as-signature-rsa-sha256", rsaSign);
                }
            }
        }

        public static string CanonicalHeader(HttpHeaders headers)
        {
            // Filter and sort headers with the "as-" prefix
            var filteredHeaders = headers
                .Where(h => h.Key.StartsWith("as-", StringComparison.OrdinalIgnoreCase))
                .OrderBy(h => h.Key, StringComparer.OrdinalIgnoreCase);

            // Build the canonicalized headers string
            string canonicalizedHeaders = string.Join(
                "\n",
                filteredHeaders.Select(h =>
                {
                    string key = h.Key.Trim();
                    string value = string.Join(",", h.Value).Trim();
                    return $"{key.ToLowerInvariant()}:{value}";
                })
            );

            return canonicalizedHeaders;
        }

        public static string CanonicalResource(HttpRequestMessage request)
        {
            Uri? uri = request.RequestUri;
            if (uri == null)
            {
                return "";
            }
            string path = uri.AbsolutePath;

            // Get query parameters and sort them by key in ascending order
            var queryParams = HttpUtility.ParseQueryString(uri.Query);
            var sortedParams = new SortedDictionary<string, string>(StringComparer.Ordinal);

            foreach (string? key in queryParams.Keys)
            {
                string? value = queryParams[key];
                if (key != null && value != null)
                {
                    sortedParams[key] = value;
                }
            }
            // Build the canonicalized resource string
            string canonicalizedResource = path;

            if (sortedParams.Count > 0)
            {
                canonicalizedResource +=
                    "?" + string.Join("&", sortedParams.Select(p => $"{p.Key}={p.Value}"));
            }

            return canonicalizedResource;
        }

        public static string SignString(
            String menthod,
            string body,
            string date,
            string canonicalHeader,
            string canonicalResource
        )
        {
            StringBuilder sb = new StringBuilder();
            string newBody = "";
            string contentType = "";
            if (!string.IsNullOrEmpty(body))
            {
                newBody = Encryption.MD5Encode(body);
                contentType = "application/json";
            }
            sb.Append(menthod).AppendLine();
            sb.Append(newBody).AppendLine();
            sb.Append(contentType).AppendLine();
            sb.Append(date).AppendLine();
            sb.Append(canonicalHeader).AppendLine();
            sb.Append(canonicalResource);
            return sb.ToString();
        }
    }
}
